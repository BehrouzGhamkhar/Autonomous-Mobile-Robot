import rclpy
from rclpy.node import Node
from nav_msgs.msg import OccupancyGrid, Path
from geometry_msgs.msg import PoseStamped
from geometry_msgs.msg import PoseWithCovarianceStamped
import numpy as np
from math import atan2
from queue import Queue

class FrontierExplorationPlanner(Node): #create the frontier node
    def __init__(self):
        super().__init__('frontier_exploration_planner')

        # Robot position and map variables
        self.robot_pose = None
        self.occupancy_grid = None

        # Parameters
        self.update_frequency = 1.0  # seconds
        self.frontier_threshold = 0.5  # Distance threshold to a frontier
        self.grid_resolution = None  # Occupancy grid resolution
        self.last_update = self.get_clock().now()

        # Subscribers for map and robot pose

        #subscribe to /map eceive the occupancy grid map from the SLAM system (generated by nav2)
        self.create_subscription(OccupancyGrid, '/map', self.map_callback, 10) 
        #subscribe to /amcl_pose to get current pose of the robot
        self.create_subscription(PoseWithCovarianceStamped, '/amcl_pose', self.pose_callback, 10)

        # Publisher for global plan path to the selected frontier
        self.path_publisher = self.create_publisher(Path, '/global_plan', 10)

    def map_callback(self, map_msg: OccupancyGrid):
        """Callback when a new map is received from SLAM"""
        now = self.get_clock().now()
        elapsed_time = (now - self.last_update).nanoseconds / 1e9

        if elapsed_time < self.update_frequency or self.robot_pose is None:
            return  # Wait for the next update

        self.last_update = now

        # Convert OccupancyGrid data to a numpy array
        width = map_msg.info.width
        height = map_msg.info.height
        self.grid_resolution = map_msg.info.resolution
        self.occupancy_grid = np.array(map_msg.data).reshape((height, width))

        # Identify frontiers (boundary regions between known and unknown space)
        frontiers = self.find_frontiers(self.occupancy_grid)
        if not frontiers:
            self.get_logger().info("No frontiers found")
            return

        # Select the closest frontier for exploration
        closest_frontier = self.find_closest_frontier(frontiers)

        # Plan a path to the selected frontier
        path = self.generate_path_to_frontier(self.robot_pose, closest_frontier)

        # Publish the path to the closest frontier
        self.publish_path(path, map_msg)


    # To update current position of the robot and convert them to map coordinates
    def pose_callback(self, pose_msg: PoseWithCovarianceStamped):
        """Callback to update the robot's current position"""
        self.robot_pose = (
            int(pose_msg.pose.pose.position.x / self.grid_resolution),
            int(pose_msg.pose.pose.position.y / self.grid_resolution)
        )

    # Again scan the map for frontiers and store them as a list
    def find_frontiers(self, occupancy_grid):
        """Identify frontiers: boundary regions between known and unknown space"""
        frontiers = []
        height, width = occupancy_grid.shape

        for y in range(1, height - 1):
            for x in range(1, width - 1):
                if occupancy_grid[y, x] == 0:  # Free space
                    neighbors = [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]
                    if any(occupancy_grid[ny, nx] == -1 for nx, ny in neighbors):  # Adjacent to unknown (-1)
                        frontiers.append((x, y))

        return frontiers

    # Calculate euclidean distance to current robot position from the detected frontier
    def find_closest_frontier(self, frontiers):
        
        min_distance = float('inf')
        closest_frontier = None

        rx, ry = self.robot_pose
        for fx, fy in frontiers:
            distance = np.sqrt((fx - rx) ** 2 + (fy - ry) ** 2)
            if distance < min_distance:
                min_distance = distance
                closest_frontier = (fx, fy)

        return closest_frontier # Choosing the closest frontier as exploration target

    # Generate a straight-line path to the frontier using linear interpolation
    def generate_path_to_frontier(self, start, frontier):
        
        path = []
        x0, y0 = start
        x1, y1 = frontier
        dx = x1 - x0
        dy = y1 - y0
        steps = max(abs(dx), abs(dy))

        for i in range(steps + 1):
            x = int(x0 + i * dx / steps)
            y = int(y0 + i * dy / steps)
            path.append((x, y))

        return path

    # Publish the path as a Path message, wach point is represented by PoseStamped
    def publish_path(self, path, map_msg):
        
        path_msg = Path()
        path_msg.header.frame_id = 'map'

        for point in path:
            pose_stamped = PoseStamped()
            pose_stamped.header.frame_id = 'map'
            pose_stamped.pose.position.x = point[0] * map_msg.info.resolution
            pose_stamped.pose.position.y = point[1] * map_msg.info.resolution
            pose_stamped.pose.position.z = 0.0
            path_msg.poses.append(pose_stamped)

        self.path_publisher.publish(path_msg)

def main(args=None):
    rclpy.init(args=args)
    planner = FrontierExplorationPlanner()
    rclpy.spin(planner)
    planner.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
