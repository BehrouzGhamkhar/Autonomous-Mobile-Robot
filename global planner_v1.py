# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qWnOcqNTTAjd4uf4d_w6Xux74lFWYs5a
"""

import rclpy
from rclpy.node import Node

from nav_msgs.msg import OccupancyGrid
from geometry_msgs.msg import PoseStamped, PoseWithCovarianceStamped
from nav_msgs.msg import Path
from math import atan2
import numpy as np

class SimpleGlobalPlanner(Node):

    def __init__(self):
        super().__init__('simple_global_planner')

        # Parameters
        self.undersampling = 1
        self.updateFrequency = 1  # Frequency in seconds
        self.wallCutOff = 50
        self.manhattan_exploration_min_distance = 1

        # Subscriptions and publishers
        self.create_subscription(PoseWithCovarianceStamped, '/pose', self.poseUpdate, 10)
        self.create_subscription(OccupancyGrid, '/map', self.mapCallback, 10)
        self.pathPublisher = self.create_publisher(Path, '/global_trajectory', 10)

        self.target = None
        self.robotPose = None
        self.lastUpdate = self.get_clock().now().to_msg()

    def mapCallback(self, msg: OccupancyGrid):
        now = self.get_clock().now()
        elapsed_time = now.sec - self.lastUpdate.sec
        if not self.robotPose or elapsed_time < self.updateFrequency:
            return

        self.lastUpdate = now
        occupancyMatrix = np.array(msg.data).reshape(msg.info.height, msg.info.width)

        # Find an exploration point
        target = self.findUnknownCell(occupancyMatrix)
        if not target:
            self.get_logger().info("No unexplored cells found.")
            return

        # Find path to the target using a simple straight-line approach
        path = self.simplePathToTarget(self.robotPose, target)

        # Publish the path
        self.publishPath(path, msg)

    def findUnknownCell(self, occupancyMatrix):
        """ Simple BFS-like search for the nearest unknown cell (-1) """
        for i in range(occupancyMatrix.shape[0]):
            for j in range(occupancyMatrix.shape[1]):
                if occupancyMatrix[i, j] == -1:
                    return (i, j)  # Return the first unexplored cell
        return None

    def simplePathToTarget(self, start, end):
        """ Simple straight line path between start and end """
        path = []
        x0, y0 = start
        x1, y1 = end
        dx = x1 - x0
        dy = y1 - y0
        steps = max(abs(dx), abs(dy))

        for i in range(steps + 1):
            x = int(x0 + i * dx / steps)
            y = int(y0 + i * dy / steps)
            path.append((x, y))

        return path

    def publishPath(self, path, map_msg):
        """ Publish the computed path """
        path_msg = Path()
        path_msg.header.frame_id = 'map'

        for point in path:
            pose_stamped = PoseStamped()
            pose_stamped.header.frame_id = 'map'
            pose_stamped.pose.position.x = point[0] * map_msg.info.resolution
            pose_stamped.pose.position.y = point[1] * map_msg.info.resolution
            pose_stamped.pose.position.z = 0.0
            path_msg.poses.append(pose_stamped)

        self.pathPublisher.publish(path_msg)

    def poseUpdate(self, msg: PoseWithCovarianceStamped):
        """ Update the robot's current position """
        self.robotPose = (msg.pose.pose.position.x, msg.pose.pose.position.y)

def main(args=None):
    rclpy.init(args=args)
    planner = SimpleGlobalPlanner()
    rclpy.spin(planner)
    planner.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()